# 样例类和模式匹配    
- 一个简单的例子...................................................[1](#A-Sample-Example)    
- 模式的种类...................................................[2](#Kids-Of-Pattern)    
- 模式守卫...................................................[3](#Pattern-Guards)    
- 模式重叠...................................................[4](#Pattern-Overlaps)    
- 密封类...................................................[5](#Sealed-Classes)    
- Option类型...................................................[6](#The-Option-Type)    
- 到处都是模式...................................................[7](#Patterns-Everywhere)    
- 一个复杂的例子...................................................[8](#A-Larger-Example)    
    
　　本节关于Scala中的*样例类（case class）* 和*模式匹配（pattern matching）* ，这组孪生的语法结构为我们编写规则的、未封装的数据结构提供
支持。这两个语法结构对于表达树形的递归数据尤其有用。    
　　模式匹配是函数式编程中的相关概念。而样例类是Scala用来对对象进行模式匹配而并不需要大量的样板代码的方式。笼统地说，要做的就是对那些希望能
做模式匹配的类加上一个case关键字。    

***    
## A-Sample-Example    
　　在深入探讨模式匹配的所有规则和细节之前，有必要先看一个简单的例子，好让我们明白模式匹配大概是做什么的。假定需要编写一个操作算数表达式的类
库，可能这个类库是正在设计的某个领域特性语言（DSL）的一部分。    
　　解决这个问题的第一步是是定义输入数据。为保持简单，我们将注意力集中在由变量、数，以及一元和二元操作符组成的算数表达式上。用Scala的类层次
结构来表达：    
```scala
abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String, left: Expr, right: Expr) extends Expr
```    
　　这个层次结构包括一个抽象的基类Expr和四个子类，每一个都表示我们要考虑一种表达式。所有五个类的定义体都是空的。如之前所提到的那样，Scala允
许省去空定义体的花括号。    

### 样例类    
　　上面示例中另一个值得注意的点是每个子类都有一个case修饰符。带有这种修饰符的类称作*样例类（case class）*。用上这个修饰符会让Scala编译器
对我们的类添加一些语法上的便利。    
　　首先，它会添加一个**跟类同名的工厂方法**。这意味着可以用“Var("x")”来构造一个Var对象，而不是稍长版本的“new Var("x")”。当需要嵌套定义
时，工厂方法尤为有用。由于代码中不再到处落满new关键字，可以一眼就看明白表达式的结构`val op = BindOp("+", Number(1), v)`。    
　　其次，第二个语法上的便利是参数列表中的参数都**隐式地获得了一个val前缀**，因此它们会被当作字段处理。    
　　再次，编译器会帮我们以“自然”的方式**实现toString、hashCode和equals方法**。这些方法分别会打印、哈希、比较包含类及所有入参的整棵树。由于
Scala的==总是代理给equals方法，这意味着样例类表示的元素总是以结构化的方式做比较：`op.right == Var("x")`。    
　　最后，编译器还会添加一个**copy方法**用于制作修改过的拷贝。这个方法用于制作一两个属性不同之外其余完全相同的该类的新实例。这个方法用到了
*带名字的参数*和*缺省参数*。用带名字的参数给出想要的修改。对于任何没有给出名字的参数，都会用老对象中的原值：`op.copy(operator = "=")`。    
　　所有这些带来的是大量的便利（代价却很小）。你需要多写一个case修饰符，并且你的类和对象会变得大那么一点。之所以更大，是因为生成了额外的方法，
并且对于构造方法的每个参数都隐式地添加字段。不过，样例类最大的好处是它们支持模式匹配。    

### 模式匹配    
　　假定想要简化算数表达式。可用的简化规则非常多，以下只列举一部分：    
```
UnOp("-", UnOp("-", e)) => e //双重取负
BinOp("+", e, Number(0)) => e //加0
BinOp("*", e, Number(1)) => e //乘1 
```     
　　用模式匹配的话，这些规则可以被看成是一个Scala编写的简化函数的核心逻辑，如下代码所示。可以这样来使用这个simplifyTop函数：    
```scala
def simplifyTop(expr: Expr): Expr = expr match {
  case UnOp("-", UnOp("-", e)) => e
  case BinOp("+", e, Number(0)) => e
  case BinOp("*", e, Number(1)) => e
  case _ => expr
}

simplifyTop(UnOp("-", UnOp("-", Var("x"))))
```    
　　simplifyTop的右边由一个match表达式组成。match表达式对应Java的switch，不过match关键字出现在选择器表达式后面。模式匹配包含一系列以
case关键字打头的*可选分支*。每一个可选分支都包括一个模式以及一个或多个表达式，如果模式匹配了，这些表达式就会被求值。箭头符`=>`用于将模式和
表达式分开。    
　　一个match表达式的求值过程是*按照模式给出的顺序逐一尝试的*。第一个模式匹配上后，表达式求值，然后返回。    
　　类似“+”和1这样的*常量模式*可以匹配那些按照`==`的要求跟它们相等的值。而像e这样的*变量模式*可以匹配任何值。匹配后，在右侧的表达式中，这个
变量指向这个匹配的值。在本例中，注意前三个可选分支都求值为e，一个在对应的模式中绑定的变量。*通配模式*，即_也匹配任何值，不过它并不会引入一个
变量名来指向这个值。在上面示例中，注意match是以一个缺省的什么都不做的case结尾的，这个缺省的case直接返回用于匹配的表达式expr。    
　　*构造方法模式*看上去就像UbOp("-", e)。这个模式匹配所有类型为UnOp且首个入参匹配"-"而第二个入参匹配e的值。注意构造方法的入参本身也是模
式。这允许我们用精简的表示法来编写有深度的模式。例如`UnOp("-", UnOp("-", e))`。    

### 对比match和switch    
　　match表达式可以被看作Java风格的switch的广义化。Java风格的switch可以很自然地用match表达式表达，其中每个模式都是常量且最后一个模式可以
是一个通配模式（代表switch中的模式case）。    
　　不过，需要记住三个区别：首先，Scala的match是一个表达式（也就是说它总能得到一个值）。其次，Scala的可选分支不会贯穿到下一个case。最后，
如果没有一个模式匹配上，会抛出名为MatchError的异常。这意味着你需要确保所有的case被覆盖到，哪怕这意味着你需要添加一个什么也不做的缺省case。    
　　参考下面示例。第二个case是必要的，因为没有它的话，match表达式对于任何非BinOp的expr入参都会抛出MatchError。在本例中，对于第二个case，
并没有给出任何代码，因此如果这个case被运行，什么都不会发生。两个case的结果都是unit值，即()，这也是这个match表达式的结果。    
```scala
expr match {
  case BinOp(op, left, right) =>
    println(expr + " is a binary operation")
  case _ =>
}
```    

***    

