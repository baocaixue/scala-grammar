# 一门可伸缩的语言    
- 一门按需伸缩的语言...................................................[1](#A-Language-That-Grows-On-You)
- 是什么让Scala能屈能伸...................................................[2](#What-Makes-Scala-Scalable)
- 为什么要用Scala...................................................[3](#Why-Scala)
- Scala寻根...................................................[4](#Scala's-Roots)    

***
　　Scala这个名字来源于“scalable language”，即“可伸缩性的语言”。之所以这样命名，是因为它的设计目标随着用户的需求一起成长。Scala可被广泛应
用于各种编程任务，从编写小型的脚本到构建巨型的系统，它都能胜任。    
　　Scala很容易上手。它运行在标准的Java平台上，可以与所有的Java类库无缝协作。它很适合编写将Java组件组装在一起的脚本。不过用Scala编写可复用组
件，并使用这些组件构建大型系统和框架时，更能体现它的威力。    
　　从技术上讲，Scala是一门综合了面向对象和函数式编程概念的静态类型的编程语言。从很多不同的角度看Scala，都能发现面向对象和函数式编程两种风格
的融合。在可伸缩性方面，这两种风格的互补性非常强。Scala的函数式编程概念让它容易从简单的组件快速构建出有趣的应用。而它的面向对象编程概念又让它能
够轻松地构造出更大的系统，并不断地适配新的要求。通过这两种编程风格结合，Scala让我们能够表达出各种新式的编程模型和组件抽象。同时，编程风格也会
变得清晰和简练。
***        
## A-Language-That-Grows-On-You   　　
　　不同大小的程序通常需要不同的编程概念。比如下面这段小程序：    
```scala
    var capital = Map("US" -> "Washington", "France" -> "Paris")
    capital += ("China" -> "Beijing")
    println(capital("China"))
```    
　　这个程序首先设置好国家和首都之间的一组映射，然后修改映射，添加一个新的绑定，最后打印出中国的首都。本例用到的表示法高级、到位并且没有多余的
分号或类型标注。的确，这段代码看上去感觉像是一款现代的“脚本”语言，比如Perl、Python或Ruby。这些语言都有一个共通点，至少就上面的实例而言是它们
各自都在语法层面支持某种“关联映射”（associative map）的结构。    
　　关联映射非常有用，因为它们让程序精简可靠，不过有时你可能不同意这种“一体适用”（one size fits all）的哲学，因为需要在程序中更为精细地控
制映射结构的性质。Scala给你这种自由度，因为映射在Scala里并不是语言本身的语法，它们是通过类库实现的一种抽象，可以按需进行扩展和适配。    
　　在上面这段程序中，得到的是默认的Map实现，不过改起来也容易。比如说，可以指定一个特定的实现，如HashMap或TreeMap，也可以通过调用par方法得
到一个并行执行操作的ParMap。可以指定映射中的默认值，也可以在创建的映射中重写任何方法。不论哪种定制，都可以复用和示例中一样的易用语法来访问映射。    

### 培育新类型　　 
　　Eric Raymond首先提出了大教堂和市集的隐喻，用来描述软件开发。大教堂指的是那种近乎完美的建筑，修建需要很长的时间，不过一旦建好，就很长时间
不做变更。而市集不同，市集用来比喻开源软件开发。Guy Steele在一次以“培育编程语言”为主题的演讲中提到，大教堂和市集的比喻也适用于编程语言设计。在
这个意义上，Scala更像是市集而不是大教堂，其主要的设计目的就是让Scala编程的人们可以对它进行扩展和定制。    
　　举个例子，很多应用程序都需要一种不会溢出（overflow）或者说“从头开始”（wrap-around）的整数。Scala正好就定义了这样一个类型`scala.BitInt`。
这里有一个使用该类型的方法，计算传入整数值的阶乘（factorial）：    
```scala
def factorial(x: BigInt): BigInt = 
    if (x == 0) 1 else x * factorial(x -1)
```    
　　BigInt看上出像是内建的，因为可以使用整形字面量，并且对这个类型的值做*和-操作符运算。但实际上它不过碰巧是Scala标准类库里定义的一个类而已。
就算没有这个类，Scala程序员也可以直接（比如对java.mat.BigInteger做一下包装）实现。实际上，Scala的BigInt就是这么做的。    
　　当然，也可以直接使用Java的这个类。不过用起来并不会给人原生支持的体验：    
```scala
import java.math.BigInteger

def factorial(x: BigInteger): BigInteger =
    if (x == 0) BigInteger.ONE
    else
      x.multiply(factorial(x.subtract(BigInteger.ONE)))
```    
　　BigInt的实现方法很有代表性，实际上还有许多其他数值类的类型（大小数、复数、有理数、置信区间、多项式等）。某些编程语言原生地支持其中某些数值类
型。举例来说，Lisp、Haskell和Python实现了大整数；而Fortran和Python则实现了复数。不过，如果某个语言要同时实现所有这些数值的抽象只会让语言的
实现变得大到不可控的程度。不仅如此，就算有这样的语言存在，总有某些应用会得益于语言提供的范围之外的类型。因此，试图在语言中提供一切的做法并不实
际。Scala允许用户定义易于使用的类库来培育和定制，最终的代码让人感觉像是语言本身支持的那样。    

### 培育新的控制结构    
　　从上一个示例可以看到，Scala允许我们添加新的类型，这些类型用起来跟内建的类型一样。像这样的扩展原则也适用于控制结构。Scala提供了一组API实
现“**基于actor的**”并发编程模型Akka，很好地展示了这种扩展性。    
　　随着多核处理器在未来几年不断普及，要到达可接收的性能指标愈发要求我们在应用程序中更多地探索和发掘并行能力。通常，这意味着重写我们的代码，让
计算可以分布在多个并发执行的线程上。不过很不幸，在实践中创建可靠的多线程应用程序非常难。Java的线程模型是围绕着共享内存（shared memory）和锁
（locking）机制实现的，这样的模型很难推敲，尤其是在系统变得越来越大，越来越复杂的背景下。很难（从分析代码）确保程序没有争用状况（race condition）
或死锁（deadlock），这些问题在测试阶段很可能根本测不出来，但在生产环境却所示可能发生。按理说，更安全的做法是采用消息传递（message passing）
的架构，比如Erlang采用“actor”方式。    
　　Java自带的给予线程的并发类库内容也很丰富，Scala程序员当然也可以像其他API那样使用它。不过，Scala也提供了一个额外的类库——Akka，实现了跟
Erlang类似的actor模型。    
　　actor是可以在线程机制之上实现的并发抽象。它们通过相互发送消息来通信。一个actor可以执行两类基本操作：发消息和收消息。发的动作用感叹号表示
（!），用于向某个actor发送消息。如下这个例子是向名为recipient的actor发送消息：    
`recipient ! msg`    
　　消息的发送是异步的，也就是说，发送消息的actor可以在发完消息后立即继续下一步操作，而不需要等到发送的消息被接收和处理。每个actor都有一个邮箱，
发到该actor的消息都会在这里排队。actor通过receive代码块来处理发送到邮箱的消息：    
```scala
def receive = {
  case Msg1 => ...//处理Msg1
  case Msg2 => ...//处理Msg2
}
```    
　　这里的receive代码块由若干样例（case）组成，每个样例都会用某个消息模式来查询邮箱。邮箱中的第一条消息如果匹配了任何一个样例，该样例就会被
选中，对应的动作就会被执行。一旦邮箱中的消息被处理完毕，actor便会暂停，等待后续的消息。    
　　举例来说，如下是用Akka实现的一个简单的actor，它可以提供计算校验和的服务：    
```scala
class ChecksumActor extends Actor {
  var sum = 0
  def receive = {
    case Data(byte) => sum += byte
    case GetChecksum(requester) =>
      val checksum = ~(sum & 0xFF) + 1
      requester ! checksum
  }
} 
```    
　　这个actor首先定义了一个sum的局部变量，并初始化为0。然后定义了一个receive代码块用于处理消息。如果它接收到一条Data消息，会将这个Data包含的
byte加到sum中。如果接收到一条GetChecksum消息，则从当前的sum计算出校验和，然后将计算结果发送给requester：requester ! checksum。requester
字段是内嵌在GetChecksum消息里的，通常都是发起请求的那个actor。    
　　这里的重点是类似receive代码块，或发送（!），都并非是Scala内建的操作指令。尽管receive代码块看上去和执行起来都像是内建的语法结构，它实际
上只是定义在Akka类库中的一个方法。同理，尽管“!”看上去像是内建的操作符，它实际上也是Akka类库中定义的一个方法。这两个结构都不是Scala语言本身原生
提供的。    
　　这里的receive代码块和发送（!）语法跟Erlang很像，不过在Erlang中，这些结构是内建在语言级的。除此之外，Akka还实现了Erlang其他绝大部分用
于并发编程的结构，比如监控和超时，总体来说，actor模型在表达并发和分布式计算方面做的非常好。尽管我们只能通过类库的方式来定义，actor用起来感觉
就像是Scala语言的一部分。    
　　可以用Scala设计和实现各式各样的抽象，应用于完全不同的领域，同时用起来仍像是语言原生支持的一样。    

***
## What-Makes-Scala-Scalable    
　　语言的伸缩性取决于很多因素，从语法细节到组件抽象都有。如果我们只能挑一个让Scala能屈能伸的方面，那就是它面向对象和函数式编程的结合。    
　　跟其他混合面向对象和函数式编程的语言相比，Scala走的更远。举例来说，其他语言可能会区分对象和函数，将它们定义为不同的两个概念，但在Scala
中，**函数值就是对象，而函数的类型是可以被子类继承的类。**    


### Scala是面向对象的    
　　从原理上讲，面向对象编程的动机非常简单：除了最微不足道的程序之外，所有程序都需要某种结构，而形成这种结构最直截了当的方式就是讲数据和操作
放进某个容器里。面向对象编程的伟大概念就是**让这类容器变得完全通用，这样它们既可以包含操作，也可以包含数据，而它们自己也可以以值的形式被存放进
其他容器中，或者作为参数传递给操作。** 这些容器被称作对象。Smalltalk的发明人，Alan Kay，认为通过这样的抽象，最简单的对象也跟完整的计算机一样，
有着相同的构造原理：它讲数据和操作结合在一个形式化的接口之下。所以说，对象跟编程语言的伸缩性之间的关系很大：同样的技巧既适用于小程序也适用于
大程序。    
　　虽然面向对象编程已经作为主流存在了很长的时间，相对而言很少有编程语言跟着Smalltalk的理念，将这个构思原理推到逻辑的终点。举例来说，许多语言
都允许不是对象的值的存在，比如Java的基本类型，又或者允许不以任何对象的成员形式存在的静态字段和方法。这些对面向对象编程理念的背离在一开始看上去
没有什么不妥，但它们更倾向于让事情变得复杂，限制了伸缩的可能。    
　　Scala则不同，它面向对象的实现是纯的：每个值都是对象，每个操作都是方法调用。举例来说，1+2，实际上在调用Int类里定义的名为+的方法。也可以定义
名字像操作符的方法，这样别人就可以用操作符表示法来使用API。Akka的API设计者就是这么做的，这也是为什么在前面的示例中可以使用requester ! sum
这样的表达式：“!”只是Actor类的一个方法而已。     
　　跟其他语言相比，在组装对象方面，Scala也更为高级。Scala的特质（trait）就是一个典型的例子。特质跟Java的接口很像，不过特质可以有方法实现甚至
是字段。对象通过*混入组合（mixin composition）*构建，构建的过程是取出某个类的所有成员，然后再加上若干特质的成员。这样一来，类的不同维度的功能
特性就可以被封装在不同的特质定义中。这乍看有点像多重集成（multiple inheritance），细看则不同。不像类，特质能够对某个未知的超类添加新的功能，
这使得特质比类更为“可插拔（pluggable）”。尤其是特质成功地避开了多重继承中，当某个子类通过不同的路径继承到同一个超类时产生的“钻石继承”（diamond
inheritance）问题。    

### Scala是函数式的    
　　Scala不只是一门纯面向对象的语言，他也是功能完整的函数式编程语言。函数式编程的概念，甚至比计算器还要早。这些理念早在20世纪30年代由Alonzo
Church开发的lambda演算（lambda calculus）中得以建立。而第一个函数式编程语言Lisp的历史，可以追溯到20世纪50年代末。其他函数式编程语言还包
括：Scheme、SML、Erlang、Haskell、OCaml、F#等。很长一段时间，函数式编程都不是主流，在学术界很受欢迎，但工业界并没有广泛使用。不过，近几年，大家
对函数式编程语言和技巧的兴趣与日俱增。    
　　函数式编程以两大核心理念为指导。**第一个理念是函数是一等（first-class）的值**。在函数式编程语言中，函数值的地位跟整数、字符串等是相同的。
可以将函数作为参数传递给其他函数，作为返回值返回它们，或者将它们保存在变量里。还可以在函数中定义另一个函数，就像函数中定义整数那样。也可以在定义
函数时不指定名字，就像整数字面量42，让函数字面量散落在代码中。    
　　作为一等值的函数提供了对操作的抽象和创建新的控制结构的便利。这种函数概念的抽象带来了强大的表现力，可以让我们写出精简可靠的代码。这一点对于
伸缩性也有恨大的帮助。以ScalaTest为例，这个测试类库提供了eventually（最后）这样的结构体，接收一个函数作为入参（argument）。用法如下：    
```scala
val xs = 1 to 3
val it = xs.iterator
eventually{ it.netxt() shouldBe 3}
```    
　　在eventually中的代码——it.next() shouldBe 3这句断言，被包在了一个函数里，该函数不会直接执行，而是原样传入eventually方法。在配置好的
时间里，eventually将会反复执行这个函数，直到断言成功。    
　　函数式编程的**第二个核心理念是程序中的操作应该讲输入值映射成输出值，而不是当场（in place）修改数据**。例如，在Ruby中，字符串是一个字符型
的数组，字符串中的字符可以单个替换。可以在同一个字符串对象中，将分号替换为逗号。而在Java和Scala中，字符串是数学意义上的字符序列。通过s.replace
(";", ",")这样的 表达式替换字符串中的某个字符，会交出（yield）一个全新的对象，而不是s、换句话说，Java的字符串是不可变的（immutable），而
Ruby的字符串是可变的（mutable）。因此仅从字符串的实现看，Java是函数式的，而Ruby不是。**不可变数据结构是函数式编程的基石之一**。Scala类库在
Java API的基础上定义了更多的不可变数据类型。比如Scala提供了不可变的列表（list）、元组（tuple）、映射（map）和集（set）等。    
　　函数式编程的这个核心概念的另一种表述方式是**方法不应该有副作用（side effect）**。方法只能通过接收入参和返回结果这两种方式与外部环境通信。    
　　函数式编程鼓励不可变数据结构和指称透明的方法。    

***

## Why-Scala    
　　Scala的最重要的四点：兼容性、精简性、高级抽象和静态类型    

### Scala是兼容的    
　　从Java带Scala，允许对现有的代码增加价值（在现有的基础上添砖加瓦），这得益于它的设计目标就是与Java的无缝互调。Scala程序会被编译成JVM字
节码，它们的运行期性能通常也跟Java程序相当。Scala代码可以调用Java方法、访问Java字段、从Java类继承、实现Java借口。要实现这些并不需要特殊的语法、
显式的接口描述或胶水代码（glue code）。事实上，几乎所有的Scala代码都重度使用Java类库，通常察觉不到这一点。    
　　关于互操作性还有一点要说明，那就是Scala也重度服用了Java的类型。Scala的Int是用Java的基本类型int实现的，Float是用Java的float实现的，
Boolean是用Java的boolean实现的，等等。Scala的数组也被映射称Java的数组。Scala还复用了Java类库中很多其他类型，比如Scala的字符串字面量"abc"
是一个java.lang.String，而抛出的异常也必须是java.lang.Throwable的子类。    
　　Scala不仅仅是复用Java的类型，也会对Java原生的类型进行“再包装”，让它们更好用。比如，Scala的字符串支持toInt或toFloat这样的方法，可以将
字符串转换成整数或浮点数。这样就可以写成str.toInt而不是Integer.parseInt(str)。如何在不打破互操作性的前提下实现呢？Java的String类当然没有
toInt方法了。事实上，Scala对于此类由于高级类库设计和互操作性之间的矛盾产生的问题有一个非常通用的解决方案：Scala支持*隐式转换（implicit 
conversion）*，当类型没有正常匹配，或者代码中选中了不存在的成员时，Scala变回尝试可能的隐式转换。在上述示例中，Scala首先在字符串的类型定义
上查找toInt方法，而String类的定义中并没有toInt这个成员（方法），不过它会找到一个将Java的String转换成Scala的StringOps类的隐式转换，
StringOps类定义了这样一个成员（方法）。因此在真正执行toInt操作之前，上述隐式转换就会被应用。    
　　我们也可以从Java中调用Scala的代码。具体的方式有时比较微妙，因为就编程语言而言，Scala比Java表达力更为丰富，所以Scala的某些高级特性需要
加工后才能映射到Java。    

### Scala是精简的    
　　Scala编写程序通常都比较短。保守估计，一个典型的Scala程序的代码行数应该只有用Java编写的同样功能的程序的一半。更少的代码不仅仅意味着打更少
的字，也让阅读和理解代码更快，缺陷也更少。更少的代码行数，归功于如下几个因素。    
　　首先，Scala的语法避免了Java程序中常见的一些样板（boilerplate）代码。比如，Scala中分号是可选的，通常大家也不写分号。Scala的语法噪声更少
还体现在其他几个方面，比如可以比较一下分别用Java和Scala来编写类和构造方法。Java的类和构造方法通常类似这样：    
```java
class MyClass{
    private int index;
    private String name;
    
    public MyClass(int index, String name) {
        this.index = index;
        this.name = name;
    } 
}
```    
　　而在Scala中，可能更倾向于写出如下的样子：    
```scala
class MyClass(index: Int, name: String)
```    
　　这段代码，Scala编译器会产出带有两个私有实例变量和一个接收这两个变量初始值的参数的构造方法的类。这个构造方法会用传入的参数值来初始化它的
两个示例变量。简单来说，用更少的代码做到了跟Java本质上相同的功能。Scala类写起来更快，读起来更容易，而最重要的是，它比Java的类出错的可能性更小。    
　　Scala的类型推断是让代码精简的另一个帮手，重复的类型信息可以去掉，这样代码就更紧凑可读。     
　　不过可能最重要的因素是有些代码根本不用写，类库都帮你写好了。Scala提供了大量的工具来定义功能强大的类库，让你可以捕获那些公共的行为，并将
它们抽象出来。例如，类库中各种类型的不同切面可以被分到不同的特质当中，然后以各种灵活的方式组装混合在一起。又比如，类库的方法也可以接收用于描述
具体操作的参数。这样一来，事实上你就可以定义自己的控制结构。所有这些加在一起，Scala让我们能够定义出抽象级别高，同时用起来又很灵活的类库。    

### Scala是高级的    
　　许多走下坡路的软件项目都受到国语复杂的代码的影响。不幸的是，重要的软件通常需求都比较复杂。这些复杂度并不能被简单地规避，必须对其进行妥善的
管理。    
　　Scala给你的帮助在于提升接口设计的抽象级别，让你更好的管理复杂度。举例来说，假定有一个String类型的变量name，想知道这个String是否包含大写
字母。在Java8之前，可能会编写这样的代码：    
```java
boolean nameHasUpperCase = false;
for(int i = 0; i < name.length(); i++) {
    if(Character.isUpperCase(name.charAt(i))) {
        nameHasUpperCase = true;
        break;
    }
}
```    
　　而在Scala中，可以这样写：    
```scala
val nameHasUpperCase = name.exists(_.isUpper)
```    
　　Java代码将字符串当做低级别的实体，在循环中逐个字符地遍历。而Scala代码将同样的字符串当作更高级别的字符序列（sequence），用前提（predicate）
来查询。显然Scala代码要短的多，并且更加易读。因此，Scala在整体复杂度预算方面是比较轻的，犯错误的机会也更少。    
　　这里的前提_.isUpper是Scala的函数字面量。它描述了一个接收字符作为入参（以下划线表示），判断该字符是否为大写字母的函数。    
　　Java8引入了对lambda和流（stream）的支持，让你能够在Java中执行类似的操作。具体代码如下：    
```java
boolean nameHasUpperCase = 
    name.chars().anyMatch(
        (ch) -> Character.isUpperCase((char) ch)
    );
```    
　　虽然跟之前版本的Java相比有了长足的进步，Java8的代码依然比Scala代码更啰嗦。     
　　另一方面，Scala的函数字面量非常轻，因此经常被使用。这种抽象避免了很多重复的代码，让程序保持短小、清晰。    

### Scala是静态类型的    
　　静态的类型系统根据变量和表达式所包含和计算的值的类型来对它们进行归类。Scala和其他语言相比，一个重要的特点是它拥有非常先进的静态类型系统。
Scala不仅拥有和Java类似的允许嵌套类型系统，它还允许用泛型来对类型进行参数化，用交集来组合类型，以及用抽象类型来隐藏类型的细节。    
　　Scala很好地解决了静态类型的两个常见的痛点：通过类型推断规避了过于啰嗦的问题，通过模式匹配以及其他编写和组合类型的方法是避免了死板。

***    

## Scala's-Roots    
　　Java和C#的语法    
　　Smalltalk、Ruby    
　　Algol、Sumula    
　　Erlang    
　　...

　　