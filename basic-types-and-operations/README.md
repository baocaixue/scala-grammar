# 基础类型和操作    
- 一些基础类型...................................................[1](#Some-Basic-Types)
- 字面量...................................................[2](#Literals)
- 字符串插值...................................................[3](#String-Interpolation)
- 操作符即方法...................................................[4](#Operators-Are-Method)
- 算术操作...................................................[5](#Arithmetic-Operations)
- 关系和逻辑操作...................................................[6](#Relational-And-Logical-Operations)
- 位运算操作...................................................[7](#Bitwise-Operations)
- 对象相等性...................................................[8](#Object-Equality)
- 操作符优先级和结合性...................................................[9](#Operator-Precedence-Associativity)
- 富包装类...................................................[10](#Rich-Wrappers)    

***
## Some-Basic-Types    
　　下表列出了Scala的一些基础类型和这些类型的实例允许的取值范围。    

 |  基础类型  | 取值区间  
 | --- | ---      
 | Byte | 8位带符号二进制补码整数（-2^7到2^7-1，闭区间）    
 | Short | 16位带符号二进制补码整数（-2^15到2^15-1，闭区间）    
 | Int | 32位带符号二进制补码整数（-2^31到2^31-1，闭区间）    
 | Long | 64位带符号二进制补码整数（-2^63到2^63-1，闭区间）    
 | Char | 16位无符号Unicode字符（0到2^16-1,闭区间）    
 | String | Char的序列    
 | Float | 32位IEEE 754单精度浮点数    
 | Double | 64位IEEE 754双精度浮点数    
 | Boolean | true或false    
 
　　Byte、Short、Int、Long和Char类型统称为*整数类型*（integral type）。整数类型加上Float和Double称作*数值类型*（numeric types）。
除了位于java.lang的String，其他的所有类型都是scala包的成员。例如，Int的完整名称为scala.Int。不过，由于scala包和java.lang包的所有成员
在Scala源文件中都已自动引入，可以在任何地方使用简单名称。 上表中Scala的基础类型和Java中对应的类型取值区间完全相同，这使得Scala编译器可以
产出的字节码中将Scala的*值类型*（value types），比如Int或Double的实例转换成Java的基本类型。    
 
***
## Literals    
　　上文表中列出的所有基础类型都可以用*字面量（literals）* 来书写。字面两是在代码中直接写入常量值的一种方式。需要注意一下 Scala原生字符串
和符号的字面量以及字符串的插值。还有就是Scala不支持八进制字面量和以0开头的整数字面量，如031,将无法通过编译。    

### 整数字面量    
　　用于Int、Long、Short和Byte的整数字面量有两种形式：十进制的和十六进制的。整数字面量的不同开头表示了不同的进制。如果是以0x或0X开头，意味
着这是十六进制的数，可以包含0到9以及大写或小写的A到F表示的数字。例如：    
```shell script
scala> val hex = 0x5
hex: Int = 5
scala> val hex2 = 0x00FF
hex2: Int = 255
scala> val magic = 0xcafebabe
magic: Int = -889275714
```    
　　注意，Scala的shell总是以十进制打印整数值，不论是用哪种形式来初始化。因此解释其把字面量0xFF初始化的变量hex2显示为十进制的255。如果字面
量以非0的数字开头，且除此之外没有其他的修饰，那么它就是十进制的。例如：    
```shell script
scala> val dec1 = 31
dec1: Int = 31
```    
　　如果整数字面量以l或L结尾，那么它就是Long类型。    
　　如果一个Int型的字面量被赋值给一个类型为Short或Byte的变量，该字面量会被当作Short或Byte类型，只要这个字面量的值在对应类型的合法取值区间
即可。    

### 浮点数字面量    
　　浮点数字面量由十进制的数字、可选的小数点、以及后续一个可选的E或e打头的指数组成。一些浮点数字的字面量如下：    
```scala
val big = 1.2345//1.2345 Double
val bigger = 1.2345e1 //1.2345 * 10^1  12.345 Double
val biggerStill = 123E45 //1.23E47 Double
```    
　　一些Float字面量如下：    
```scala
val little = 1.2345F
val littleBigger = 3e5f//300000.0 Float
```    

### 字符字面量    
　　和Java一样，如`val a = '\u0041'`    

### 字符串字面量    
　　Scala支持一种特殊的语法来表示*原生的字符串*。可以用三个双引号来使用。原生字符串内部可以包含任何字符，包括换行、单引号等特殊字符。当然，
连续三个双引号除外。可以看下面例子：    
```scala
println("""Welcome to Ultamix 3000.
           Type "HELP" for help. """)
//管道符，stripMargin调整
println("""|Welcome to Ultamix 3000.
           |Type "HELP" for help. """.stripMargin)
```    
### 符号字面量    
　　符号字面量的写法是'ident，其中ident可以是任何由字母和数字组成的标识符。这样的字面量会被映射成scala.Symbol这个预定义类的实例。确切的
说，字面量'cymbal会被编译器展开成一个工厂方法的调用：Symbol("cymbal")。符号字面量通常用在那些在动态类型语言中用来当作标识符的场合。例如，
定义一个更新数据库记录的方法：    
```scala
def updateRecordByName(r: Symbol, value: Any)
```    
　　这个方法以参数的形式接收一个符号和一个值，分别表示记录中要更新的字段和值。在动态语言中，可以传入一个未声明的字段标识来调用这个方法，但在
Scala中不行。不过，可以传入一个符号字面量，和动态语言同样精简：`updateRecordByName('favoriteAlbum, "Ok Computer")`。
　　对于符号，能做的不过，除了获取它的名字：`val name = r.name`。另一个需要注意的是，符号会被内部化（所谓内部化，可以参考Java对Long对象
的处理，最常用的-127～128L会被内部化，即重用对象而不是新建）。如果同样的符号字面量出现两次，这两次引用都会指向同一个Symbol对象。        

### 布尔字面量    
　　true  &&  false
***

## String-Interpolation    
　　Scala包括了一个灵活的机制来支持字符串插值，允许在字符串字面量中嵌入表达式。最常见的用途是为字符串拼接提供一个更为精简和易读的替代方案：    
```scala
val name = "reader"
println(s"Hello, $name")
```    
　　表达式`s"Hello, $name"`是一个被处理的（processed）字符串字面量。由于字母s出现在首个双引号前，Scala将使用s这个字符串插值器来处理该
字面量。*s插值器*会对内嵌的每个表达式求值，对求值的结果调用toString，替换掉字面量中的那些表达式。因此 `s"Hello, $name"` == `"Hello" + 
name"`    
　　在被处理的字符串字面量中，可以随时用美元符（$）开始一个表达式。对于那些单变量的表达式，通常可以在美元符后面直接给出变量的名字。而对于包含
了非标识字符的表达式可以如下处理：    
```scala
println(s"The answer is ${6 * 7}")
```    

　　Scala还提供了另外两种字符串插值器：*raw和f*。raw字符串插值器行为和s类似，不过它并不识别字符转义序列。如：`println(raw"No\\\\smoking)`
的结果为“No\\\\smoking”。    
　　f字符串插值器允许给内嵌的表达式加上printf风格的指令。需要将指令方法在表达式之后，以百分号（%）开始。如：`println(f"${math.Pi}%.2f")`    
如果不对内嵌表达式给出任何格式化指令，f字符串插值器将模式使用%s，其含义是用toString的值来替换。    
　　在Scala中，字符串插值是通过在编译期重写代码来实现的。编译器会将任何由某个标识符紧接着的字符串字面量（左）双引号这样表达式当作字符串插值器
表达式来处理。字符串插值器s、f和raw，就是通过这个通用的机制实现的。类库作者和用户可以定义其他字符串插值器来满足不同的用途。    

***    

## Operators-Are-Method    
　　Scala给它的基础类型提供了一组丰富的操作符，这些操作符实际上只是普通的方法调用的漂亮语法。如，1 + 2实际上跟1.+(2)是一回事。事实上，Int
包含了多个重载的+方法，分别接收不同的参数类型。例如，Int还有一个+方法，接收一个Long，返回一个Long。    
　　+符号是一个操作符（更确切地说是一个中缀操作符）。操作符表示法并不局限于譬如“+”这种看上去像操作符的，可以在操作符表示法中使用任何方法。如
String类有一个indexOf方法，接收一个Char参数。可以这样使用：    
```scala
val s = "Hello, World!"
s indexOf '!'
```    
　　除此之外，String还提供了一个重载的indexOf方法，可以这样：    
```scala
val s = "Hello, World!"
s indexOf ('o', 5)
```    
　　*任何方法都可以是操作符*    
　　在Scala中，操作符并不是特殊的语法，任何方法都可以是操作符。当“s.indexOf('o')”时，indexOf不是操作符;但当使用“s indexOf 'o''”时，
indexOf就是操作符了，因为使用的是操作符表示法。    

　　至此，都是*中缀操作符*表示法的若干案例，中缀操作符表示法格式： 对象 中缀标识符 参数。Scala还提供了另外两种操作符表示法：前缀和后缀。
在前缀表示法中，需要将方法名放到需要调用方法的对象前面。在后缀表示法中，需要将方法名放在对象之后。    

　　跟中缀操作符表示法不同，前缀和后缀操作符是一元的：它们只接受一个操作元。前缀操作符的例子有 -2.0、!found和~0xFF等。跟中缀操作符类似，这
些前缀操作符也是调用方法的一种简写。不同的是，方法名称是**unary\_** 加上操作符。例如-2.0这样的表达式转换成如下的方法调用：`(2.0).unary_-`。
*唯一能被用作前缀操作符的是+、-、!、~*。    

　　后缀操作符是那些不接收参数并且在调用时没有用英文句点圆括号的方法。在Scala中，可以在方法调用时省去空的圆括号。从约定俗成的角度讲，如果方法
有副作用的时候保留空的圆括号，如println();而在方法没有副作用时可以省掉这组圆括号，比如对String调用toLowerCase。    

***
## Arithmetic-Operations    
　　算术操作：+ - * / %  和Java都一样。    

***    
## Relational-And-Logical-Operations    
　　关系和逻辑操作：>  <  >=  <=  !  、 &&  &   ||  |    
　　*注意：*    
　　操作符只是方法，短路是如何做到的。通常，所有入参都会在进入方法之前被求值，所以作为方法，逻辑操作符是如何做到不对第二个参数求值的呢。答案
是所有Scala方法都有一个机制来延迟对入参的求值，或者干脆不对它们求值。这个机制叫做*传名参数*。    

***    
## Bitwise-Operations    
　　位运算操作：按位与（&）、按位或（|）、按位异或（^）、一元的位补码（~）、左移（<<）、右移（>>）、无符号右移（>>>）    
　　1 & 2     1(0001) & 2(0010)   --->    0(0000)     
　　1 | 2     1(0001) | 2(0010)   --->    3(0011)    
　　1 ^ 3     1(0001) ^ 3(0011)   --->    2(0010)     相同的位交出0,不同的位交出1    
　　~1        ~ 1(0001)       --->    -2(1111 1111 1111 1111 1111 1111 1111 1110)     每一位取反    

　　-1>>31    (1111 1111 1111 1111 1111 1111 1111 1111) ---> 右移31位（左侧值最高位的值-符号位来填充），-1    
　　-1>>>31   (1111 1111 1111 1111 1111 1111 1111 1111) ---> 无符号右移31位（填充0），1    
　　1<<2      (0000 0000 0000 0000 0000 0000 0000 0001) ---> 左移2位（填充0），4    
***    


