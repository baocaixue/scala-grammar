# Scala入门（续）    
- 第7步 用类型参数化数组...................................................[1](#Parameterize-Arrays-With-Type)
- 第8步 使用列表...................................................[2](#Use-Lists)
- 第9步 使用元祖...................................................[3](#Use-Tuples)
- 第10步 使用集和映射...................................................[4](#Use-Set-Amd-Maps)
- 第11步 识别函数式编程风格...................................................[5](#Recognize-Functional-Style)
- 第12步 从文件读取文本行...................................................[6](#Read-Lines-From-File)    

***    
## Parameterize-Arrays-With-Type    
　　在Scala中，可以用new来实例化对象或类的实例。当使用Scala实例化对象时，可以用值和类型对其进行*参数化（parameterize）*。参数化的意思是
**在创建实例时对实例做“配置”**。可以用值来参数化一个实例，做法是在构造方法的括号中传入对象的参数。例如，如下代码将实例化一个新的java.math.
BigInteger，并用值“12345”对它进行参数化：    
　　`val bigInt = new java.math.BigInteger("12345")`    
　　也可以用类型来参数化一个实例，做法是在*方括号里*给出一个或多个类型：    
```scala
val greetStrings = new Array[String](3)
greetStrings(0) = "Hello"
greetStrings(1) = ", "
greetStrings(2) = "world!\n"

greetStrings.foreach(print)
```    
　　**注意：** 上面代码示例只做概念的展示，这并不是Scala创建并初始化数组的推荐方法    
　　
　　Scala的数组访问方式是将下标放在圆括号里，而不是像Java那样放到中括号里。同时，这里也展示了Scala关于val的一个重要概念。当用val定义一个变量
时，变量本身不能被重新赋值，但它指向的那个对象是有可能发生改变的。本例中，不能将greetStrings重新赋值成另一个数组，不过可以改变那个Array[String]
的元素，因此数组本身是可变的（mutable）。    

```scala
for (i <- 0 to 2) println(arr(i))
```    

　　上面代码，这个for表达式展示了Scala的另一个通行的规则：如果一个方法只接收一个参数，在调用它的时候，可以不使用英文句点。本例中的to实际上是
一个Int参数的方法。代码0 to 2会被转换为(0).to(2)。注意这种方式仅在给出方法调用的目标对象时才有效。即调用方式是这样：“目标对象 方法 参数”。    

　　Scala从技术上讲并没有操作符重载（operator overloading），因为它实际上并没有传统意义上的操作符。类似+、-、×、/这样的字符可以被用作方法名。
因此，例如往Scala解释器中键入1+2时，实际上调用了Int对象1上名为+的方法，将2作为参数传入。也可以用传统的方式来写1+2这段代码：(1).+(2)。    

　　这里展示的另一个重要理念是为什么Scala用圆括号（而不是方括号）来访问数组。跟Java相比Scala的特例更少。数组不过是类的实例，这一点跟其他Scala
实例并没有本质区别。当用一组圆括号将一个或多个值抱起来，并将其应用（apply）到某个对象时，Scala会将这段代码转换为对这个对象的一个名为apply的
方法的调用。所以array(i)会被转换为array.apply(i)。因此，在Scala中访问一个数组的元素就是一个简单的方法调用。当然，这样的代码仅在对象的类型
实际上定义了apply方法时才能通过编译。因此，这并不是一个特例，这是一个通行规则。    

　　同理，当我们尝试通过圆括号应用一个或多个参数的变量进行赋值时，编译器会将代码转换成update方法的调用，这个update方法接收两个参数：圆括号
括起来的值，以及等号右边的对象。例如：    
　　`array(0) = "Hello"`    
　　会被转换为：    
　　`array.update(0, "Hello")`    

　　Scala将数组到表达式的一切都当做带有方法的对象来处理，由此来实现概念上的简单化。不需要记住各种特例，比如Java中的基本类型与它们对应的包装
类型的区别，或数组和常规对象的区别等。不仅如此，这种统一并不带来显著的性能开销。Scala在编译代码时，会尽可能使用Java数组、基本类型和原生的算数
指令。    

　　Scala还提供了一种比通常做法更精简的方式来创建和初始化数组：    
```scala
val numNames = Array("zero", "one", "two")
```     
　　这实际上是调用了一个名为apply的工厂方法，这个方法创建并返回了新的数组。这个apply方法接收一个变长的参数列表，该方法定义在Array的*伴生对象
（companion object）* 中。可以想象成是调用了Array类的一个名为apply的静态方法。    

***

　　

