# 组合和继承
- 一个二维的布局类库...................................................[1](#A-TwoDimensional-Layout-Library)
- 抽象类...................................................[2](#Abstract-Classes)
- 定义无参方法...................................................[3](#Defining-Parameterless-Methods)
- 扩展类...................................................[4](#Extending-Classes)
- 重写方法和字段...................................................[5](#Overriding-Methods-And-Fields)
- 定义参数化字段...................................................[6](#Defining-Parametric-Fields)
- 调用超类构造方法...................................................[7](#Invoking-Superclass-Constructors)
- 使用override修饰符...................................................[8](#Using-Override-Modifiers)
- 多态和动态绑定...................................................[9](#Polymorphism-And-Dynamic-Binding)
- 声明final成员...................................................[10](#Declaring-Final-Members)
- 使用组合和继承...................................................[11](#Using-Composition-And-Inheritance)
- 实现above、beside和toString...................................................[12](#Implementing-Above-Beside-And-Tostring)
- 定义工厂对象...................................................[13](#Defining-A-Factory-Object)
- 增高和增宽...................................................[14](#Heighten-And-Widen)
- 放在一起...................................................[15](#Putting-It-All-Together)    

***    
## A-TwoDimensional-Layout-Library    
　　这里将创建一个用于构建和渲染二维布局元素的类库作为示例。每个元素表示一个用文本填充的长方形。为方便起见，类库将提供名为“elem”的工厂方法，
从传入的数据构造新的元素。例如，可以用下面这个签名的工厂方法传见一个包含字符串的布局元素：     
```scala
def elem(s: String): Element
```    
　　用一个名为Element的类型来对元素建模。可以对一个元素调用above或beside，传入另一个元素，来获取一个将两个元素结合在一起的新元素。例如，
下面这个表达式将创建一个由两列组成的更大的元素，每一列的高度都为2：    
```scala
val column1 = elem("hello") above elem("***")
val column2 = elem("***") above elem("world")
column1 beside column2
```    
　　打印上述表达式的结果将得到：    
```
hello ***
*** world
```    
　　布局元素很好地展示了这样一个系统：在这个系统中，对象可以通过组合操作符的帮助由简单的部件构建出来。这里将定义那些可以从数组、线和巨型构造
出元素对象的类，这些基础的元素对象是我们说的简单部件，我们还会定义组合操作符above和beside。这样的组合操作符通常也被称作组合子，因为它们将
某个领域内的元素组合成新的元素。    
　　用组合子来思考通常是一个设计类库的好办法：对于某个特定的应用领域中对象，它们有那些基本的构造方式，这样的思考是很有意义的。简单的对象如何
构造出更有趣的对象？如何将组合子有机地结合在一起？最通用的组合有哪些？它们是否满足某种有趣的法则？如果对这些问题都有很好的答案，那么你的类库
设计就走在正轨上。    

***    
## Abstract-Classes    
　　首先要定义Element类型，用来表示元素。由于元素是一个由字符组成的二维矩阵，用一个成员contents来表示某个布局元素的内容。内容可以用字符串
的数组表示，每个字符串代表一行。因此，由contents返回的结果类型将会是Array[String]：    
```scala
abstract class Element {
  def contents: Array[String]
}
```    
　　这个类中，contents被声明为一个没有实现的方法。换句话说，这个方法是Element类的*抽象*成员。一个包含抽象成员的类本身也要声明为抽象的，做
法是在class关键字前加上abstract修饰符，和Java一样抽象类也是不能直接实例化的。可以创建Element的子类，这些子类是可以实例化的。    
　　需要注意，Element类中的contents方法并没有标上abstract修饰符。一个方法只要没有实现（即没有等号或方法体），那么它就是抽象的。跟Java不
同，不需要（也不能）对方法加上abstract修饰符。那些给出了实现的的方法叫做*具体（concrete）* 方法。另一组在叫法上的区分是*声明*和*定义*。
Element类声明了contents这个抽象方法，但目前没有定义具体的方法。下面，将通过定义一些具体的方法来增强Element。    

***    
## Defining-Parameterless-Methods
　　现在，我们将给Element添加方法来获取它的宽度和高度，如下所示。height方法返回contents中的行数。而width方法返回第一行的长度，如果完全
没有内容则返回0。    
```scala
abstract class Element {
  def contents: Array[String]
  def height: Int = contents.length
  def width: Int = if (height == 0) 0 else contents(0).length
}
```    
　　注意，Element的三个方法无一例外都没有参数列表，连空参数列表都没有。这样的*无参方法（parameterless method）* 在Scala中很常见。于此对
应，那些用空的圆括号定义的方法，如`def height(): Int`被称作*空圆括号方法（empty-paren method）* 。推荐的做法是*对没有参数且只通过读取
所在对象字段方式访问可变状态（确切地说不改变状态）的情况下尽量使用无参方法*。这样的做法支持所谓的*统一访问原则*：使用方代码不应该收到某个属
性是用字段还是用方法实现的影响。    
　　举例来说，完全可以吧width和height实现成字段，而不是方法，只要将定义中的def换成val即可：    
```scala
abstract class Element {
  def contents: Array[String]
  val height: Int = contents.length
  val width: Int = if (height == 0) 0 else contents(0).length
}
```    
　　从使用方代码看，这组定义完全等价。唯一的区别是字段访问可能比方法调用略快，因为字段值在类初始化时就被预先计算好，而不是每次方法调用时重新
计算。另一方面，字段需要每个Element对象为其分配额外的内存空间。因此属性实现为字段好还是方法好，这个问题取决于类的用法，而用法可以随着时间变
化而变化的。核心点在于Element类的使用方不应爱被内部实现的变化所影响。具体来说，当Element的某个字段被改成访问函数时，Element的使用方代码不需要被重新编写，只要这个访问函数是纯的（即它没有副作用也不依赖于可变
状态）。使用方代码不需要关心究竟是哪一种实现。    
　　但现在有一个问题，这跟Java处理细节有关。Java并没有实现统一访问原则。因此Java中要写`string.length()`而不是`string.length`，而对于
数组要写`array.length`而不是`array.length()`，这让人很困扰。为了更好地桥接这两种写法，Scala对于混用无参方法和空括号方法的处理非常灵活。
具体来说，可以用空括号方法重写无参方法，反过来也可以。还可以在调用某个不需要入参的方法时省去空括号。    
　　从原理上讲，可以对Scala所有无参函数调用都去掉空括号。不过，仍然建议在被调用的方法不仅代表接收该调用的对象的某个属性时加上空括号。举例来说，
空括号的场景包括该方法执行I/O、写入可冲ixn赋值的变量var、读取接收该调用对象字段之外的var（不论是直接还是间接地使用了可变对象）。这样以来，
参数列表就可以作为一个视觉上的线索，告诉我们调用触发了某个有趣的计算。    
　　总结下来就是，Scala鼓励我们将那些不接收参数也没有副作用的方法定义为无参方法。同时，对有副作用的方法，不应该省去空括号。    

***    
