# 组合和继承
- 一个二维的布局类库...................................................[1](#A-TwoDimensional-Layout-Library)
- 抽象类...................................................[2](#Abstract-Classes)
- 定义无参方法...................................................[3](#Defining-Parameterless-Methods)
- 扩展类...................................................[4](#Extending-Classes)
- 重写方法和字段...................................................[5](#Overriding-Methods-And-Fields)
- 定义参数化字段...................................................[6](#Defining-Parametric-Fields)
- 调用超类构造方法...................................................[7](#Invoking-Superclass-Constructors)
- 使用override修饰符...................................................[8](#Using-Override-Modifiers)
- 多态和动态绑定...................................................[9](#Polymorphism-And-Dynamic-Binding)
- 声明final成员...................................................[10](#Declaring-Final-Members)
- 使用组合和继承...................................................[11](#Using-Composition-And-Inheritance)
- 实现above、beside和toString...................................................[12](#Implementing-Above-Beside-And-Tostring)
- 定义工厂对象...................................................[13](#Defining-A-Factory-Object)
- 增高和增宽...................................................[14](#Heighten-And-Widen)
- 放在一起...................................................[15](#Putting-It-All-Together)    

***    
## A-TwoDimensional-Layout-Library    
　　这里将创建一个用于构建和渲染二维布局元素的类库作为示例。每个元素表示一个用文本填充的长方形。为方便起见，类库将提供名为“elem”的工厂方法，
从传入的数据构造新的元素。例如，可以用下面这个签名的工厂方法传见一个包含字符串的布局元素：     
```scala
def elem(s: String): Element
```    
　　用一个名为Element的类型来对元素建模。可以对一个元素调用above或beside，传入另一个元素，来获取一个将两个元素结合在一起的新元素。例如，
下面这个表达式将创建一个由两列组成的更大的元素，每一列的高度都为2：    
```scala
val column1 = elem("hello") above elem("***")
val column2 = elem("***") above elem("world")
column1 beside column2
```    
　　打印上述表达式的结果将得到：    
```
hello ***
*** world
```    
　　布局元素很好地展示了这样一个系统：在这个系统中，对象可以通过组合操作符的帮助由简单的部件构建出来。这里将定义那些可以从数组、线和巨型构造
出元素对象的类，这些基础的元素对象是我们说的简单部件，我们还会定义组合操作符above和beside。这样的组合操作符通常也被称作组合子，因为它们将
某个领域内的元素组合成新的元素。    
　　用组合子来思考通常是一个设计类库的好办法：对于某个特定的应用领域中对象，它们有那些基本的构造方式，这样的思考是很有意义的。简单的对象如何
构造出更有趣的对象？如何将组合子有机地结合在一起？最通用的组合有哪些？它们是否满足某种有趣的法则？如果对这些问题都有很好的答案，那么你的类库
设计就走在正轨上。    

***    
## Abstract-Classes    
　　首先要定义Element类型，用来表示元素。由于元素是一个由字符组成的二维矩阵，用一个成员contents来表示某个布局元素的内容。内容可以用字符串
的数组表示，每个字符串代表一行。因此，由contents返回的结果类型将会是Array[String]：    
```scala
abstract class Element {
  def contents: Array[String]
}
```    
　　这个类中，contents被声明为一个没有实现的方法。换句话说，这个方法是Element类的*抽象*成员。一个包含抽象成员的类本身也要声明为抽象的，做
法是在class关键字前加上abstract修饰符，和Java一样抽象类也是不能直接实例化的。可以创建Element的子类，这些子类是可以实例化的。    
　　需要注意，Element类中的contents方法并没有标上abstract修饰符。一个方法只要没有实现（即没有等号或方法体），那么它就是抽象的。跟Java不
同，不需要（也不能）对方法加上abstract修饰符。那些给出了实现的的方法叫做*具体（concrete）* 方法。另一组在叫法上的区分是*声明*和*定义*。
Element类声明了contents这个抽象方法，但目前没有定义具体的方法。下面，将通过定义一些具体的方法来增强Element。    

***    
